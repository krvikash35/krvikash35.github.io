<article>
    <h2>Instantiation Pattern</h2>
    <p>
        In Javascript, every thing is either function or object. We need to write our object or function in such a way that it is
        testable, maintainable and re-usable.There are many design Pattern regarding Instantiation of Object in Javascript.
        Some of them are:
    </p>

    <ul>
        <li>Functional</li>
        <li>Functional Shared</li>
        <li>Prototypal</li>
        <li>Pseudo classical</li>
        <li>ES6 Pseudo classical</li>
    </ul>

    <blockquote>
        We should write factory function for better testability. factory function are function which return object. Above pattern
        will have either factory or non-factory function version. we can convert non-factory to factory version.
    </blockquote>

    <h4>Factory function</h4>
    <pre><code>
Class Student(){
}
function factory(){
    return new Student()
}
    </code></pre>

    <h4>Functional pattern</h4>
    <pre><code>
var House = function(color){
    var obj = {};
    obj.color = color;
    object.openDoor = function(){ obj.door = 'open' };
    object.closeDoor = function(){ obj.door = 'close' };
    return obj;
}
var red_house = House('red');
        </code></pre>
        <p>
            Good point about this pattern is it is very <em>clear to read and understand</em>. its pure functional. its factory function version. But
            problem is it is <em>memory inefficient</em> because each created object will have its own copy of method, though its same.
        </p>

        <h4>Functional shared pattern</h4>
        <pre><code>
var House = function(color){
    var obj = {};
    obj.color = color;
    object.openDoor = houseMethods.openDoor;
    object.closeDoor = houseMethods.closeDoor;
    return obj;
}
var houseMethods = {}
houseMethods.openDoor = function(){ this.door = 'open' };
houseMethods.closeDoor = function(){ this.door = 'close' };
var red_house = House('red');
        </code></pre>
<p>
    It is factory function version. Now the mothod will be be shared through <em>object reference</em> accross all created object. It is more memory
    efficient compare to function but it is less efficient than delegating a fallback. 
</p>


<h4>Prototypal</h4>
<pre><code>
var House = function(color){
    var obj = Object.create(House.prototype)
    obj.color = color;
    obj.door = 'open';
    return obj;
}
var houseMethods = {}
House.prototype.openDoor = function(){ this.door = 'open' };
House.prototype.closeDoor = function(){ this.door = 'close' };
var red_house = House('red');
        </code></pre>
<p>
    This is pure functional factory version. Many old and pure Javascript programmer prefer this pattern.
</p>

<h4>Pseudo classical</h4>
<pre><code>
var House = function(color){
    obj.color = color;
    obj.door = 'open';
}
var houseMethods = {}
House.prototype.openDoor = function(){ this.door = 'open' };
House.prototype.closeDoor = function(){ this.door = 'close' };
var red_house = new House('red');
        </code></pre>
        <p>
            As the name suggest, it is not pure classical, its as <em>syntatic sugar of Prototypal pattern</em>. It was introduce in ES5, to bring 
            familliar syntax of popular class based language(i.e java). In true sense, Javascript does not have concept of class, and inheritance
            happens through prototype instead of classical.
        </p>

        <h4>ES6 Pseudo classical</h4>
        <pre><code>
Class House{
    constructor(color){
        this.color = color;
        this.door = 'open';
    }
    openDoor() { this.door = 'open' };
    closeDoor() { this.door = 'close' }
}
var red_house = new House('red');
        </code></pre>
        <p>
            It is one step furthur to Pseudo classical pattern. Many keyword and syntax were introduce in ES6 to make it more like other pure class
            based language. this is also an syntatic sugar of Prototypal pattern. only good thing about this is, it <em>reduce LOC</em> to 
            acheive same. Bad thing is that it gives a <em>wrong sense of classical</em> concept in Javascript.
        </p>

</article>


<article>
    <h2>Callack Promise Asyn-Await</h2>
    <p>
        Javascript has support for asynchronous operation i.e it provide some asynchronous api or we can write our own asynchronous code.
        asynchronous code/operation does not hold cpu time to finish it work, instead notify it caller, when it finishes its job through some machanism.
        Code is executed line be line, if previous line is asynchronous then next line will not wait for previous line to finish. So we can not 
        simpley write asynchronous code in synchronous syntax, until there is language support.
    </p>
    <h4>Callback</h4>
    <pre><code>
//INCORRECT WAY...using normal synchronous syntax
var a = getSomeAsyncValue(); // return asynchronously
var result = a*2; // no guarantee of expected result
console.log(result);

//CORRECT WAY...using callback
getSomeAsyncValue( function(a){
  var result = a*2;
  console.log(result)
})

//CORRECT WAY...another better callback way
var callback = function(a){
    var result = a*2;
    console.log(result);
}
getSomeAsynValue(callback);
    </code></pre>
    <p>
        Callback function is function that can be passed to <em>another function as argument</em>. once called function finished, it should 
        call callback function. So callback function is a way to write asynchronous code in javascript. But writing is this way will create
        <em>callback hell</em>, when there will be a lot of asynchronous function call. callback hell create readability and maintainability
        problem. It can be reduced by following some good javascript coding pattern, but not upto the mark.
    </p>
    
    <h4>Promise</h4>
 <pre><code>
 //CALLBACK HELL...
 getSomeAsyncValue( function(a){
    getAnotherAsynValue( function(b){
        getAnotherAsynValue2( function(c){
        ...do some work here
        }
    })
 })
 
 //PROMISE...solve callback hell
 getSomeAsyncValue()
    .then( function(a){
        return getAnotherAsynValue()
    })
    .then( function(b){
        return getAnotherAsynValue2()
    })
    .then( function(c){
        ...do some work here, if promise is resolved
    })
    .cath( function(){
        ...cath error here, if promise is rejected
    })
    
 //PROMISE CREATION SYNTAX
 function fnMyPromise(){
    return Promise( (resolve, reject) => {
        ...do some async operation here, get data or error
        ...if operation is success, then resolve otherwise reject
        if(success){
            resolve(data)
        }else{
            reject(err)
        }
    })
 }
 </code></pre>
    <p>
        As seen above promise is much better to <em>look and read</em>, so it solve callback hell problem. So what exactly is promise,
        how we can write function that return promise. Promise has two state <em>Waiting</em> and <em> Finished</em>. When finished
        it will return result with either rejected or resolved. 
    </p>
    
    <h2>Asyn-Await</h2>
    <pre><code>
async function fnMyAsync() {
 try{
   var a = await getSomeAsyncValue();
   var b = await getAnotherAsynValue();
   var c = await getAnotherAsynValue2();
   ...do some work here
 }catch(e){
  ...catch error here
 }
}
    </code></pre>
    <p>
        Asyn await is a way to write asynchronous code in synchronous syntax. its highly readble and managable, quite compareable to 
        pure synchronous code. It will be introduced in ES7 or ES8, but its already there in node 7. its <em>build on top of promise</em>
        . we can convert normal callback function to promise, but the same <em>can not be converted</em> to asyn function directly. 
        To convert normal callback to asyn function, first convert callback to promise then promise to async. So to use asyn await,
        we must have promise in first place. Note, await must be called <em>inside async funtion only</em>, otherwise it will not work.
    </p>
    
</article>
