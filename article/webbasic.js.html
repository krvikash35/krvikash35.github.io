<article>
    <h2>Instantiation Pattern</h2>
    <p>
        In Javascript, every thing is either function or object. We need to write our object or function in such a way that it is
        testable, maintainable and re-usable.There are many design Pattern regarding Instantiation of Object in Javascript.
        Some of them are:
    </p>

    <ul>
        <li>Functional</li>
        <li>Functional Shared</li>
        <li>Prototypal</li>
        <li>Pseudo classical</li>
        <li>ES6 Pseudo classical</li>
    </ul>

    <blockquote>
        We should write factory function for better testability. factory function are function which return object. Above pattern
        will have either factory or non-factory function version. we can convert non-factory to factory version.
    </blockquote>

    <h4>Factory function</h4>
    <pre><code>
Class Student(){
}
function factory(){
    return new Student()
}
    </code></pre>

    <h4>Functional pattern</h4>
    <pre><code>
var House = function(color){
    var obj = {};
    obj.color = color;
    object.openDoor = function(){ obj.door = 'open' };
    object.closeDoor = function(){ obj.door = 'close' };
    return obj;
}
var red_house = House('red');
        </code></pre>
        <p>
            Good point about this pattern is it is very <em>clear to read and understand</em>. its pure functional. its factory function version. But
            problem is it is <em>memory inefficient</em> because each created object will have its own copy of method, though its same.
        </p>

        <h4>Functional shared pattern</h4>
        <pre><code>
var House = function(color){
    var obj = {};
    obj.color = color;
    object.openDoor = houseMethods.openDoor;
    object.closeDoor = houseMethods.closeDoor;
    return obj;
}
var houseMethods = {}
houseMethods.openDoor = function(){ this.door = 'open' };
houseMethods.closeDoor = function(){ this.door = 'close' };
var red_house = House('red');
        </code></pre>
<p>
    It is factory function version. Now the mothod will be be shared through <em>object reference</em> accross all created object. It is more memory
    efficient compare to function but it is less efficient than delegating a fallback. 
</p>


<h4>Prototypal</h4>
<pre><code>
var House = function(color){
    var obj = Object.create(House.prototype)
    obj.color = color;
    obj.door = 'open';
    return obj;
}
var houseMethods = {}
House.prototype.openDoor = function(){ this.door = 'open' };
House.prototype.closeDoor = function(){ this.door = 'close' };
var red_house = House('red');
        </code></pre>
<p>
    This is pure functional factory version. Many old and pure Javascript programmer prefer this pattern.
</p>

<h4>Pseudo classical</h4>
<pre><code>
var House = function(color){
    obj.color = color;
    obj.door = 'open';
}
var houseMethods = {}
House.prototype.openDoor = function(){ this.door = 'open' };
House.prototype.closeDoor = function(){ this.door = 'close' };
var red_house = new House('red');
        </code></pre>
        <p>
            As the name suggest, it is not pure classical, its as <em>syntatic sugar of Prototypal pattern</em>. It was introduce in ES5, to bring 
            familliar syntax of popular class based language(i.e java). In true sense, Javascript does not have concept of class, and inheritance
            happens through prototype instead of classical.
        </p>

        <h4>ES6 Pseudo classical</h4>
        <pre><code>
Class House{
    constructor(color){
        this.color = color;
        this.door = 'open';
    }
    openDoor() { this.door = 'open' };
    closeDoor() { this.door = 'close' }
}
var red_house = new House('red');
        </code></pre>
        <p>
            It is one step furthur to Pseudo classical pattern. Many keyword and syntax were introduce in ES6 to make it more like other pure class
            based language. this is also an syntatic sugar of Prototypal pattern. only good thing about this is, it <em>reduce LOC</em> to 
            acheive same. Bad thing is that it gives a <em>wrong sense of classical</em> concept in Javascript.
        </p>

</article>


<article>
    <h2>Callack Promise Asyn-Await</h2>
    <p>
        Javascript has support for asynchronous operation i.e it provide some asynchronous api or we can write our own asynchronous code.
        asynchronous code/operation does not hold cpu time to finish it work, instead notify it caller, when it finishes its job through some machanism.
        Code is executed line be line, if previous line is asynchronous then next line will not wait for previous line to finish. So we can not 
        simpley write asynchronous code in synchronous syntax, until there is language support.
    </p>
    <h4>Callback</h4>
    <pre><code>
//INCORRECT WAY...using normal synchronous syntax
var a = getSomeAsyncValue(); // return asynchronously
var result = a*2; // no guarantee of expected result
console.log(result);

//CORRECT WAY...using callback
getSomeAsyncValue( function(a){
  var result = a*2;
  console.log(result)
})

//CORRECT WAY...another better callback way
var callback = function(a){
    var result = a*2;
    console.log(result);
}
getSomeAsynValue(callback);
    </code></pre>
    <p>
        Callback function is function that can be passed to <em>another function as argument</em>. once called function finished, it should 
        call callback function. So callback function is a way to write asynchronous code in javascript. But writing is this way will create
        <em>callback hell</em>, when there will be a lot of asynchronous function call.
    </p>
</article>
